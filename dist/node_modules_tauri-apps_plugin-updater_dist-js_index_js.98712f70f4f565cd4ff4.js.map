{"version":3,"file":"node_modules_tauri-apps_plugin-updater_dist-js_index_js.98712f70f4f565cd4ff4.js","mappings":";;;;;;;;;;;;;;;AAAiE;;AAEjE;AACA;AACA;AACA,qBAAqB,0DAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAO;AACnC;AACA;AACA;AACA,yCAAyC,4DAAM;AAC/C;AACA;AACA;AACA,SAAS;AACT,mCAAmC,0DAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAM;AACpB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAO;AACnC;AACA;AACA;AACA,cAAc,4DAAM;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4DAAM;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA,6CAA6C,mCAAmC;AAChF;AACA;AACA;AACA;AACA;AACA;;AAEyB","sources":["webpack://telegram-t/./node_modules/@tauri-apps/plugin-updater/dist-js/index.js"],"sourcesContent":["import { Resource, Channel, invoke } from '@tauri-apps/api/core';\n\n// Copyright 2019-2023 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\nclass Update extends Resource {\n    constructor(metadata) {\n        super(metadata.rid);\n        this.available = true;\n        this.currentVersion = metadata.currentVersion;\n        this.version = metadata.version;\n        this.date = metadata.date;\n        this.body = metadata.body;\n        this.rawJson = metadata.rawJson;\n    }\n    /** Download the updater package */\n    async download(onEvent, options) {\n        convertToRustHeaders(options);\n        const channel = new Channel();\n        if (onEvent) {\n            channel.onmessage = onEvent;\n        }\n        const downloadedBytesRid = await invoke('plugin:updater|download', {\n            onEvent: channel,\n            rid: this.rid,\n            ...options\n        });\n        this.downloadedBytes = new Resource(downloadedBytesRid);\n    }\n    /** Install downloaded updater package */\n    async install() {\n        if (!this.downloadedBytes) {\n            throw new Error('Update.install called before Update.download');\n        }\n        await invoke('plugin:updater|install', {\n            updateRid: this.rid,\n            bytesRid: this.downloadedBytes.rid\n        });\n        // Don't need to call close, we did it in rust side already\n        this.downloadedBytes = undefined;\n    }\n    /** Downloads the updater package and installs it */\n    async downloadAndInstall(onEvent, options) {\n        convertToRustHeaders(options);\n        const channel = new Channel();\n        if (onEvent) {\n            channel.onmessage = onEvent;\n        }\n        await invoke('plugin:updater|download_and_install', {\n            onEvent: channel,\n            rid: this.rid,\n            ...options\n        });\n    }\n    async close() {\n        await this.downloadedBytes?.close();\n        await super.close();\n    }\n}\n/** Check for updates, resolves to `null` if no updates are available */\nasync function check(options) {\n    convertToRustHeaders(options);\n    const metadata = await invoke('plugin:updater|check', {\n        ...options\n    });\n    return metadata ? new Update(metadata) : null;\n}\n/**\n * Converts the headers in options to be an {@linkcode Array<[string, string]>} which is what the Rust side expects\n */\nfunction convertToRustHeaders(options) {\n    if (options?.headers) {\n        options.headers = Array.from(new Headers(options.headers).entries());\n    }\n}\n\nexport { Update, check };\n"],"names":[],"sourceRoot":""}