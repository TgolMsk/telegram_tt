"use strict";
(self["webpackChunktelegram_t"] = self["webpackChunktelegram_t"] || []).push([["node_modules_tauri-apps_plugin-updater_dist-js_index_js"],{

/***/ "./node_modules/@tauri-apps/plugin-updater/dist-js/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tauri-apps/plugin-updater/dist-js/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Update: () => (/* binding */ Update),
/* harmony export */   check: () => (/* binding */ check)
/* harmony export */ });
/* harmony import */ var _tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tauri-apps/api/core */ "./node_modules/@tauri-apps/api/core.js");


// Copyright 2019-2023 Tauri Programme within The Commons Conservancy
// SPDX-License-Identifier: Apache-2.0
// SPDX-License-Identifier: MIT
class Update extends _tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_0__.Resource {
    constructor(metadata) {
        super(metadata.rid);
        this.available = true;
        this.currentVersion = metadata.currentVersion;
        this.version = metadata.version;
        this.date = metadata.date;
        this.body = metadata.body;
        this.rawJson = metadata.rawJson;
    }
    /** Download the updater package */
    async download(onEvent, options) {
        convertToRustHeaders(options);
        const channel = new _tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_0__.Channel();
        if (onEvent) {
            channel.onmessage = onEvent;
        }
        const downloadedBytesRid = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_0__.invoke)('plugin:updater|download', {
            onEvent: channel,
            rid: this.rid,
            ...options
        });
        this.downloadedBytes = new _tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_0__.Resource(downloadedBytesRid);
    }
    /** Install downloaded updater package */
    async install() {
        if (!this.downloadedBytes) {
            throw new Error('Update.install called before Update.download');
        }
        await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_0__.invoke)('plugin:updater|install', {
            updateRid: this.rid,
            bytesRid: this.downloadedBytes.rid
        });
        // Don't need to call close, we did it in rust side already
        this.downloadedBytes = undefined;
    }
    /** Downloads the updater package and installs it */
    async downloadAndInstall(onEvent, options) {
        convertToRustHeaders(options);
        const channel = new _tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_0__.Channel();
        if (onEvent) {
            channel.onmessage = onEvent;
        }
        await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_0__.invoke)('plugin:updater|download_and_install', {
            onEvent: channel,
            rid: this.rid,
            ...options
        });
    }
    async close() {
        await this.downloadedBytes?.close();
        await super.close();
    }
}
/** Check for updates, resolves to `null` if no updates are available */
async function check(options) {
    convertToRustHeaders(options);
    const metadata = await (0,_tauri_apps_api_core__WEBPACK_IMPORTED_MODULE_0__.invoke)('plugin:updater|check', {
        ...options
    });
    return metadata ? new Update(metadata) : null;
}
/**
 * Converts the headers in options to be an {@linkcode Array<[string, string]>} which is what the Rust side expects
 */
function convertToRustHeaders(options) {
    if (options?.headers) {
        options.headers = Array.from(new Headers(options.headers).entries());
    }
}




/***/ })

}]);
//# sourceMappingURL=node_modules_tauri-apps_plugin-updater_dist-js_index_js.98712f70f4f565cd4ff4.js.map